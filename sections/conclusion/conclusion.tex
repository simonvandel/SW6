\chapter{Conclusion}\label{ch:conclusion}


In the following conclusion we will summarise the project, and our efforts towards solving the problem statement that was set at the start of the project:

\vspace{0.5 cm}
\begin{center}
	\textbf{\textit{How can we develop an application that, using aSTEP services, can analyse position data gathered from events that attracts large crowds, identify relevant information about the behavior of the crowds, and present this information to event staff in an intuitive manner?}}
\end{center}

Our solution to the problem was a web application. The application was developed across four sprints, following an agile development process. Three of the four sprints were evaluated with an interview with a potential user of the system, and the remaining sprint was evaluated internally. This method of development worked great for the project, since it synchronised our work with the other groups in the multi-project. The deadlines at the end of the sprints and the following planning of a new sprint, also helped us keep the development on the right track.

The application was built from a set of requirements, which we chose based on the previously mentioned evaluation interviews. The requirements were prioritised based on their importance through the MoSCoW method. While most of the requirements were not[...] \kanote{forsæt omkring requirements efter gennemlæsning af requirements}

The application was separated naturally into a front-end and back-end, where the front-end was to solve the subproblem of presenting the crowd information to the event staff in an intuitive manner. The back-end in turn dealt with the other subproblem of analysis position data, in order to indentify relevant information about the behavior of crowds.

The back-end solved the problem through a central analyser-module which calculated crowd factors. These factors, which were discovered in related work, had shown themselves to be effective in the assessment of crowd behavior. The calculation of the crowd factors was based on previous work, but was modified to fit our specific problem. Because it was discovered that the system was required to do the analysis in real-time, work on optimising the back-end was done through a design of an asynchronous process, which allowed the analysis to run separately from the rest of the back-end. In addition to the design, a complexity optimisation of the algorithm through advanced data structures significantly increased the speed at which analysis was done.

\kanote{overvej om der bør være noget om kommunikationen imellem back- \& front-end}

The front-end solves its subproblem as web service, which displays the information it receives from the back-end. The front-end is built around a map, upon which the information is displayed. This is done through the activation of different overlays, in


%Hvad har vi gjort?

%Hvordan gik det?

%Hvad er vi tilfredse med?

%Hvad er vi mindre tilfredse med?